{
  "version": 3,
  "sources": ["../src/core/render.ts", "../src/core/template/bindings.ts", "../src/core/template/factory.ts", "../src/core/template/parser.ts", "../src/core/template/bound.ts", "../src/core/noop.ts", "../src/core/easy.ts", "../src/core/wait.ts", "../src/main.ts"],
  "sourcesContent": ["import { TemplateBindings } from './template/bindings'\nimport { concatValues } from './values'\n\nexport function css(strings: TemplateStringsArray, ...values: unknown[]) {\n  const style = document.createElement('style')\n  style.textContent = concatValues(strings, values)\n  return style\n}\n\nexport function html(strings: TemplateStringsArray, ...values: unknown[]) {\n  const template = document.createElement('template')\n  template.innerHTML = concatValues(strings, values)\n  return template\n}\n\nexport function tmpl(strings: TemplateStringsArray, ...values: unknown[]) {\n  const template = document.createElement('template')\n  template.innerHTML = strings.join('')\n  return template\n}\n\nexport abstract class EasyRenderElement extends HTMLElement {\n  bind!: <T extends Record<string, any>>(data: T) => void\n  swap!: (name: string, value: any) => void\n}\n", "import {\n  BoundNode,\n  BoundAttributeNode,\n  BoundEventHandlerNode,\n  BoundPropertyNode,\n} from './interfaces'\nimport { ElementProps } from './types'\n\nfunction isBoundEventHandlerNode(\n  node: BoundNode\n): node is BoundEventHandlerNode {\n  return node.hasOwnProperty('eventName')\n}\n\nfunction isBoundPropertyNode(node: BoundNode): node is BoundPropertyNode {\n  return node.hasOwnProperty('propName')\n}\n\n/**\n * Fornece uma interface simples para\n * inser\u00E7\u00E3o de dados em um template\n */\nexport class TemplateBindings {\n  _map: Map<string, BoundNode[]>\n\n  constructor(bindingsMap: Map<string, BoundNode[]>) {\n    this._map = bindingsMap\n  }\n\n  setData(data: Record<string, any>) {\n    Object.keys(data).forEach((key) => this.set(key, data[key]))\n  }\n\n  set(name: string, value: any) {\n    const boundNodes = this._map.get(name)\n    if (boundNodes) {\n      for (let boundNode of boundNodes) {\n        const { node } = boundNode\n        if (node.nodeType === Node.TEXT_NODE) {\n          node.textContent = value.toString()\n        } else if (isBoundEventHandlerNode(boundNode)) {\n          const { eventHandler, eventName } = boundNode\n          node.removeEventListener(eventName, eventHandler)\n          node.addEventListener(eventName, value)\n          boundNode.eventHandler = value\n        } else if (isBoundPropertyNode(boundNode)) {\n          ;(node as ElementProps).props[boundNode.propName] = value\n        } else {\n          const { values, originalValue } = boundNode as BoundAttributeNode\n          values.set(name, value.toString())\n\n          let attrValue = originalValue\n\n          if (values) {\n            values.forEach((value, name) => {\n              attrValue = attrValue.replace(`{{${name}}}`, value)\n            })\n          }\n\n          ;(node as Attr).value = attrValue\n        }\n      }\n    }\n  }\n}\n", "import { TemplateBindings } from './bindings'\nimport {\n  BoundNode,\n  BoundAttributeNode,\n  BoundEventHandlerNode,\n  BoundPropertyNode,\n} from './interfaces'\nimport { ElementProps } from './types'\n\ninterface Binding {\n  path: number[]\n}\n\ninterface TextBinding extends Binding {\n  name: string\n}\n\ninterface AttributeBinding extends Binding {\n  names: string[]\n  attrName: string\n  eventName: string\n  isProperty: boolean\n}\n\n/**\n * Stores info about bindings for a parsed template. It can then apply the\n * binding info to a cloned instance of the template quickly and return a\n * TemplateBindings instance to interact with the data directly.\n */\nexport class TemplateBindingsFactory {\n  private _textBindings: TextBinding[] = [\n    {\n      name: '',\n      path: [],\n    },\n  ]\n  private _attributeBindings: AttributeBinding[] = []\n\n  constructor() {\n    this._textBindings = []\n    this._attributeBindings = []\n  }\n\n  addTextBinding(name: string, path: number[]) {\n    this._textBindings.push({ name, path: path.slice() })\n  }\n\n  addAttributeBinding(names: string[], attrName: string, path: number[]) {\n    const eventName = (\n      attrName.startsWith('on-') ? attrName.substr(3) : ''\n    ).replace(/-([a-z])/g, (g) => g[1].toUpperCase())\n    const isProperty = attrName.endsWith('$')\n\n    this._attributeBindings.push({\n      names,\n      attrName,\n      eventName,\n      isProperty,\n      path: path.slice(),\n    })\n  }\n\n  applyTo(node: Node) {\n    const bindingsMap = new Map<string, BoundNode[]>([])\n\n    for (let { name = '', path = [] } of this._textBindings) {\n      const nodeToBind = this.findNodeFromPath(node, path)\n\n      nodeToBind.textContent = ''\n\n      if (!bindingsMap.has(name)) {\n        bindingsMap.set(name, [])\n      }\n\n      bindingsMap.get(name)?.push({\n        node: nodeToBind,\n      })\n    }\n\n    for (let binding of this._attributeBindings) {\n      const { names, attrName, path, eventName, isProperty } = binding\n\n      const nodeToBind = this.findNodeFromPath(node, path)\n\n      const attrNode = (nodeToBind as Element).getAttributeNode(\n        attrName\n      ) as Attr\n\n      if (eventName && attrNode) {\n        const ownerElement = attrNode.ownerElement as ElementProps\n        const binding: BoundEventHandlerNode = {\n          node: ownerElement,\n          eventName,\n          eventHandler: null,\n        }\n\n        ownerElement.removeAttribute(attrNode.name)\n        if (!bindingsMap.has(names[0])) {\n          bindingsMap.set(names[0], [])\n        }\n\n        bindingsMap.get(names[0])?.push(binding)\n      } else if (isProperty) {\n        const ownerElement = attrNode.ownerElement as ElementProps\n        const propName = attrNode.name\n          .slice(0, -1)\n          .replace(/-([a-z])/g, (g) => g[1].toUpperCase())\n\n        const binding: BoundPropertyNode = {\n          node: ownerElement,\n          propName,\n        }\n\n        ownerElement.props = ownerElement.props || {}\n        ownerElement.props[propName] = null\n        ownerElement.removeAttribute(attrNode.name)\n        if (!bindingsMap.has(names[0])) {\n          bindingsMap.set(names[0], [])\n        }\n\n        bindingsMap.get(names[0])?.push(binding)\n      } else {\n        const binding: BoundAttributeNode = {\n          node: attrNode,\n          originalValue: attrNode.value,\n          values: new Map<string, string>(),\n        }\n\n        for (let name of names) {\n          if (!bindingsMap.has(name)) {\n            bindingsMap.set(name, [])\n          }\n\n          binding.values.set(name, '')\n          bindingsMap.get(name)?.push(binding)\n        }\n\n        let attrValue = binding.originalValue\n        binding.values.forEach((value, name) => {\n          attrValue = attrValue.replace(`{{${name}}}`, value)\n        })\n        // for (let [name, value] of binding.values) {\n        //   attrValue = attrValue.replace(`{{${name}}}`, value)\n        // }\n\n        attrNode.value = attrValue\n      }\n    }\n    return new TemplateBindings(bindingsMap)\n  }\n\n  findNodeFromPath(node: Node, path: number[]) {\n    let result = node\n    for (let pathSegment of path) {\n      result = result.childNodes[pathSegment]\n    }\n    return result\n  }\n}\n", "import { TemplateBindingsFactory } from './factory'\n\n/**\n * Respons\u00E1vel por analisar um HTMLTemplateElement e\n * transform\u00E1-lo em uma inst\u00E2ncia TemplateBindingsFactory\n * que pode ent\u00E3o produzir TemplateBindings\n * para inst\u00E2ncias individuais do template.\n */\nexport class TemplateBindingsParser {\n  static BINDING_REGEX = /{{([a-zA-z0-9]*)}}/\n\n  static parse(template: HTMLTemplateElement) {\n    const bindings = new TemplateBindingsFactory()\n\n    this.parseNodes(bindings, template.content.childNodes, [])\n\n    return bindings\n  }\n\n  /**\n   * Percorre os elementos procurando\n   * template bindings\n   */\n  static parseNodes(\n    bindings: TemplateBindingsFactory,\n    nodes: NodeList,\n    path: number[]\n  ) {\n    /**\n     * Fazemos uma travessia em profundidade\n     * dos n\u00F3s com visita de prefixo para\n     * realmente analisar liga\u00E7\u00F5es\n     */\n    for (let i = 0; i < nodes.length; i++) {\n      path.push(i)\n      this.parseNode(bindings, nodes[i], path)\n      path.pop()\n    }\n  }\n\n  // Verifica template bindings de 1 node\n  static parseNode(\n    bindings: TemplateBindingsFactory,\n    node: Node,\n    path: number[]\n  ) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return this.parseTextBindings(bindings, node as Text, path)\n    }\n\n    if (node instanceof Element) {\n      if (node.hasAttributes()) {\n        this.parseAttributes(bindings, node.attributes, path)\n      }\n\n      if (node.hasChildNodes()) {\n        this.parseNodes(bindings, node.childNodes, path)\n      }\n    }\n  }\n\n  // Analisa os atributos de um n\u00F3 para ver\n  // se eles t\u00EAm alguma vincula\u00E7\u00E3o de modelo\n  static parseAttributes(\n    bindings: TemplateBindingsFactory,\n    attributes: NamedNodeMap,\n    path: number[]\n  ) {\n    for (let i = 0; i < attributes.length; i++) {\n      this.parseAttribute(bindings, attributes[i], path)\n    }\n  }\n\n  // Analisa um \u00FAnico n\u00F3 de atributo\n  // para liga\u00E7\u00F5es de modelo\n  static parseAttribute(\n    bindings: TemplateBindingsFactory,\n    attribute: Attr,\n    path: number[]\n  ) {\n    const regex = new RegExp(this.BINDING_REGEX.source, 'g')\n    const names: string[] = []\n    let match = regex.exec(attribute.value)\n    while (match) {\n      names.push(match[1])\n      match = regex.exec(attribute.value)\n    }\n\n    if (names.length) {\n      bindings.addAttributeBinding(names, attribute.name, path)\n    }\n  }\n\n  // Analisa um \u00FAnico n\u00F3 de texto\n  // para liga\u00E7\u00F5es de modelo\n  static parseTextBindings(\n    bindings: TemplateBindingsFactory,\n    node: Text,\n    path: number[]\n  ) {\n    const regex = new RegExp(this.BINDING_REGEX.source, 'g')\n    const match = regex.exec(`${node.textContent}`)\n    if (match) {\n      if (match.index) {\n        node.splitText(match.index)\n        return\n      }\n\n      if (node.length > match[0].length) {\n        node.splitText(match[0].length)\n      }\n\n      const name = match[1]\n      bindings.addTextBinding(name, path)\n    }\n  }\n}\n", "import { TemplateBindingsFactory } from './factory'\nimport { TemplateBindingsParser } from './parser'\nimport { TemplateBindings } from './bindings'\n\n/**\n * Esta classe transforma um TemplateHTMLElement padr\u00E3o para\n * uma factory que cria inst\u00E2ncias de clones de templates\n * com bindings nomeados que atualizam dinamicamente o DOM.\n */\nexport default class BoundTemplate {\n  _bindingsFactory: null | TemplateBindingsFactory\n  _template: HTMLTemplateElement\n\n  constructor(template: HTMLTemplateElement) {\n    this._bindingsFactory = null\n    this._template = template\n  }\n\n  /**\n   * Cria um clone do template e objeto de bindings associado.\n   * Se esta for a primeira inst\u00E2ncia criada, tamb\u00E9m \u00E9\n   * executado a an\u00E1lise inicial do template.\n   */\n  create(data?: object): [Node, TemplateBindings] {\n    if (!this._bindingsFactory) {\n      this._bindingsFactory = TemplateBindingsParser.parse(this._template)\n    }\n\n    const instance = this._template.content.cloneNode(true)\n    const bindings = this._bindingsFactory.applyTo(instance)\n\n    if (data) {\n      bindings.setData(data)\n    }\n\n    return [instance, bindings]\n  }\n}\n", "export const noop = () => null;", "import BoundTemplate from './template/bound'\nimport { noop } from './noop'\n\nexport type EasyOptions<T> = {\n  name: string\n  tmpl?: HTMLTemplateElement\n  style?: HTMLStyleElement\n} & ShadowRootInit\n\nexport function Easy<T>(options: EasyOptions<T>) {\n  const { name, tmpl, style, mode } = options\n  return function <T extends CustomElementConstructor>(target: T) {\n    const connected = target.prototype.connectedCallback ?? noop\n\n    target.prototype.connectedCallback = function () {\n      const shadow: ShadowRoot = this.attachShadow({ mode })\n      if (style) shadow.appendChild(style)\n\n      if (tmpl) {\n        const bound = new BoundTemplate(tmpl)\n        const [instance, bindings] = bound.create(this)\n\n        target.prototype.bind = (data: T) => {\n          bindings.setData(data)\n        }\n        target.prototype.swap = (name: string, value: any) => {\n          bindings.set(name, value)\n        }\n\n        shadow.appendChild(instance)\n      }\n\n      connected.call(this)\n    }\n\n    customElements.define(name, target)\n  }\n}\n", "/**\n * @param time tempo de espera para execu\u00E7\u00E3o, em segundos\n */\nexport const wait = (time: number) => {\n  /**\n   * @param fn fun\u00E7\u00E3o a ser executada\n   */\n  return (fn: () => void) => {\n    setTimeout(fn, time * 1000)\n  }\n}", "import { EasyRenderElement, tmpl } from './core/render'\nimport { Easy } from './core/easy'\nimport { wait } from './core/wait'\n\nimport './style.css'\n\n@Easy({\n  mode: 'open',\n  name: 'easy-element',\n  tmpl: tmpl`\n    <h1>Text {{text}}</h1>\n\n    <input type=\"week\" value=\"{{value}}\" />\n  `,\n})\nexport class MyEasyElement extends EasyRenderElement {\n  connectedCallback() {\n    this.bind({ text: '123' })\n    \n    wait(2)(() => {\n      const value = '2021-W40'\n\n      this.swap('text', value)\n      this.swap('value', value)\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
